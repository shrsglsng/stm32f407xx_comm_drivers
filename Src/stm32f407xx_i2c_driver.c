#include "stm32f407xx_i2c_driver.h"
static void I2C_GenerateStartCondition(I2C_RegDef_t *I2Cx);
void I2C_PeriClkControl(I2C_RegDef_t *xI2C, uint8_t EnOrDis)
{
    if (xI2C == I2C1)
    {
        EnOrDis ? I2C1_CLK_EN() : I2C1_CLK_DIS();
    }
    else if (xI2C == I2C2)
    {
        EnOrDis ? I2C2_CLK_EN() : I2C2_CLK_DIS();
    }
    else if (xI2C == I2C3)
    {
        EnOrDis ? I2C3_CLK_EN() : I2C3_CLK_DIS();
    }
}

/* i2c init logic
- init i2c mode (master mode: standaed / fast)
- init i2c serial clk speed
- config device address (applicable when device is configured to slave)
- enable i2c acking
- configure i2c rise time
-  */

void I2C_Init(I2C_Handle *I2C_Handle)
{

    /* enable acking */
    I2C_Handle->xI2C->CR1 |= (I2C_Handle->I2C_ConfigParameters->I2C_AckControl << I2C_CR1_ACK);

    /* configuring freq bits */

    I2C_Handle->xI2C->CR2 |= ((RCC_GetClk1Value() / 1000000U) & 0x3F);

    /* configuring own address if device in slave mode */

    I2C_Handle->xI2C->OAR1 |= (I2C_Handle->I2C_ConfigParameters->I2C_DeviceAddress << 1);
    I2C_Handle->xI2C->OAR1 |= 1 << 14; // 14-th bit has to be set by software according to r.m

    /* configuring ccr value (scl- serial clk ; pclk- peripheral clk)*/

    /* if Sm mode:
                    CCR = Fpclk / (2 * Fscl)
        if Fm mode:
            if DUTY = 0 then CCR =  Fpclk / 3 * (Fscl)

            if DUTY = 1  then CCR = Fpclk / 25 * (Fscl)
    */
    uint16_t ccr_value; // remember ccr is a 12-bit value, so if we init uint16 we need to mask the trailing 12 bits by 0xfff

    if (I2C_Handle->I2C_ConfigParameters->I2C_SclkSpeed <= I2C_SCL_SPEED_SLOW)
    {
        /* i2c is configured in slow mode */
        ccr_value = (RCC_GetClk1Value() / (2 * I2C_Handle->I2C_ConfigParameters->I2C_SclkSpeed));
        I2C_Handle->xI2C->CCR |= ccr_value & 0xFFF;
    }
    else
    {
        /* i2c configuref in fast mode */
        /* for fast mode; set 15th bit of rcc(f/s) to enable fast mode) */
        I2C_Handle->xI2C->CCR |= (1 << 15);
        /* and also configure the duty cycle int the 14th bit */
        I2C_Handle->xI2C->CCR |= (I2C_Handle->I2C_ConfigParameters->FMDutyCycle << 14);

        if (I2C_Handle->I2C_ConfigParameters->FMDutyCycle == I2C_FM_DUTY_2)
        {
            /* DUTY=0 */
            ccr_value = RCC_GetClk1Value() / (3 * I2C_Handle->I2C_ConfigParameters->I2C_SclkSpeed);
            I2C_Handle->xI2C->CCR |= (ccr_value & 0xFFF);
        }
        else
        {
            ccr_value = RCC_GetClk1Value() / (25 * I2C_Handle->I2C_ConfigParameters->I2C_SclkSpeed);
            I2C_Handle->xI2C->CCR |= (ccr_value & 0xFFF);
        }
    }

    /* TODO; config trise */
}

/* send and receive api's */

void I2C_MasterSendData(I2C_Handle *pI2CHandle, uint8_t *pTxBuffer, uint32_t length, uint8_t slave_address)
{

    /* step1: generate start condition */

    I2C_GenerateStartCondition(pI2CHandle->xI2C);

    /* step2: ckeck if start condition is generated by polling SB bit */

    while(!(I2C_GetFlagStatus(pI2CHandle->xI2C, I2C_FLAG_SB)));

    /* step3; write the 7bit slave address + 1bit r/w into DR1, this event also completes the software responsibility of clear SB bit */

    pI2CHandle->xI2C->DR = (slave_address << 1) & ~(1);

    /*step 4: check if the address phase is completed by checking the ADDR bit */

    while(!(I2C_GetFlagStatus(pI2CHandle->xI2C, I2C_FLAG_ADDR)));

    /* step 5: dummy read SR2 to clear ADDR flag */

    uint32_t dummyread = pI2CHandle->xI2C->SR2;

    /* step 6: send data until len=0 */

    while(length >0){
        while(!(I2C_GetFlagStatus(pI2CHandle->xI2C, I2C_FLAG_TxE))); //wait till txe bit is set, ensures that the DR is empty before writing to it

        pI2CHandle->xI2C->DR = *(pTxBuffer);
        pTxBuffer++;
        length--;
    }

    /* step 7: wait until txe=1 and btf = 1 to ensure the transmission is complete */

    while(!(I2C_GetFlagStatus(pI2CHandle->xI2C, I2C_FLAG_TxE)));
    while(!(I2C_GetFlagStatus(pI2CHandle->xI2C, I2C_FLAG_BTF)));

    /* step 8: generate STOP condition */

    pI2CHandle->xI2C->CR1 |= (1 << I2C_CR1_STOP);

    /*   */
}

/* support functions for data transmission */

static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
    pI2Cx->CR1 |= (1 << I2C_CR1_START);
}

void I2C_DeInit(I2C_RegDef_t *xI2C)
{
    if (xI2C == I2C1)
    {
        I2C1_RESET();
    }
    else if (xI2C == I2C2)
    {
        I2C2_RESET();
    }
    else if (xI2C == I2C3)
    {
        I2C3_RESET();
    }
}

uint8_t I2C_GetFlagStatus(I2C_RegDef_t *xI2C, uint8_t FlagName)
{
    if (xI2C->SR1 & FlagName)
    {
        return FLAG_SET;
    }
    else
    {
        return FLAG_RESET;
    }
}

void I2C_PeripheralControl(I2C_RegDef_t *xI2C, uint8_t EnOrDis)
{
    if (EnOrDis)
    {
        xI2C->CR1 |= (1 << I2C_CR1_PE);
    }
    else
    {
        xI2C->CR1 &= ~(1 << I2C_CR1_PE);
    }
}

/* remember this is configuring interrput for the gpio that will use the i2c bus */

void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnOrDis)
{
    if (EnOrDis)
    {
        if (IRQNumber <= 31)
        {
            *NVIC_ISER0 |= (1 << IRQNumber);
        }
        else if (IRQNumber > 31 && IRQNumber <= 63)
        {
            *NVIC_ISER1 |= (1 << IRQNumber);
        }
        else if (IRQNumber > 63 && IRQNumber <= 95)
        {
            *NVIC_ISER2 |= (1 << IRQNumber);
        }
    }
    else
    {
        if (IRQNumber <= 31)
        {
            *NVIC_ICER0 |= (1 << IRQNumber);
        }
        else if (IRQNumber > 31 && IRQNumber <= 63)
        {
            *NVIC_ICER1 |= (1 << IRQNumber);
        }
        else if (IRQNumber > 63 && IRQNumber <= 95)
        {
            *NVIC_ICER2 |= (1 << IRQNumber);
        }
    }
}

void I2C_InterruptPriority(uint8_t IRQNumber, uint32_t Priority)
{
    uint8_t priority_reg_number = IRQNumber / 4;
    uint8_t priority_position_within_reg = IRQNumber % 4;

    *(NVIC_PR_BASEADDR + priority_reg_number) |= Priority << ((8 * priority_position_within_reg) + (8 - NO_PR_BITS_IMPLEMENTED));
}
